---
sidebar_label: 'Creating Bots'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Creating Bots

Regression Games bots are flexible and highly customizable.
Bots can simulate player behavior, function as NPCs, interact with menus and UIs, validate gameplay, and more.

Bots run in the Regression Games runtime and connect to your game via socket connections initiated from your Unity integration.
Bots receive the current game state every few tick until they disconnect.
Our Javascript APIs allow bots to make decisions based on these game state updates and perform actions that interact with game elements.

## Configurations

The first step to setting up your Javascript bot-code is configuring the bot instance.
Implement the following methods to provide important information to your Unity Integration for spawning and terminating this bot.  

### `isSpawnable();`

Specifies whether this bot should be represented by a visible component in the game.
Bots that simulate players or NPCs are generally spawnable, 
while bots that interact with menus, represent environmental hazards, observe the game state without interaction, etc. are not.  

#### Arguments
None

#### Return Value
boolean (Default `true`)

#### Examples

```javascript
isSpawnable() {
    return false;
}
```

### `getCharacterConfig();`

For spawnable bots. Provides an object containing character configurations to help seat your bot as the appropriate class/prefab/etc.
This is a freeform object to be interpreted by your game's implementation of the `RGBotSpawnManager.SeatPlayer` and `RGSpawnManager.SpawnBot` interfaces.

#### Arguments
None

#### Return Value
string

#### Examples

<Tabs>
<TabItem value="character_config_simple" label="Simple definition" default>

```javascript
getCharacterConfig() {
    return {
        "type" : "Mage"
    }
}
```

</TabItem>
<TabItem value="character_type_freeform" label="Complex definition" default>

```javascript
getCharacterConfig() {
    return {
        "class": "Warrior",
        "subClass": "Reaver",
        "startingEquipment": {
            "mainHand": "Sword",
            "offHand": "Sword"
        },
        "spawn": "BlueTower",
        "maxHP": "50"
    }
}
```

</TabItem>
</Tabs>

### `getBotLifeCycle();`

Bots can be either `managed` or `persistent`.
A `managed` bot will automatically disconnect when the game-scene is destroyed (???).
A `persistent` bot must either terminate itself when its tasks are complete or be terminated manually from the RG Overlay.

#### Arguments
None

#### Return Value
One of `"MANAGED"` or `"PERSISTENT"`.

#### Examples
<Tabs>
<TabItem value="managed_bot" label="Managed" default>

```javascript
getBotLifeCycle() {
    return 'MANAGED'
}
```

</TabItem>
<TabItem value="persistent_bot" label="Persistent" default>

```javascript
getBotLifeCycle() {
    return 'PERSISTENT'
}
```

</TabItem>
</Tabs>


### `isComplete();`

Allows a bot to disconnect itself from the game before the Unity integration would normally signal bots to disconnect.

#### Arguments
None

#### Return Value
boolean

#### Examples

```javascript
let tasksComplete = false;
isComplete() {
    return tasksComplete;
}
```


## Defining Dynamic Bot Behaviors

Your Unity integration collects state information about game objects and notifies the bot runtime with the updated state at a fixed tick interval.
Whenever the bot runtime receives an update, Regression Games calls the `runTurn` method. This is the entrypoint into your bot logic for each tick.        

The following API is used to evaluate the current game state within `runTurn` and queue behaviors you've defined as `RGActions`.
Methods that filter state objects and check conditions also record results which can be loaded into the Unity bot replay to help visualize the bot's decison-making at each tick.  

:::note 
Dynamic Bot Commands evaluate the game state for the current tick only. 
This contrasts with [bot validation](./creating-bots#validation-testing-with-bots), which may delay execution of commands for several ticks until expected prerequisites have been met. 
:::

<Tabs>
<TabItem value="runTurn_coopBot" label="Follow and support a human player as an NPC" default>

```javascript

import { CharInfo } from "../bossroom";

let charType = 3; // Archer

/**
 * Defines the type of character that the game should use for this bot (in this case an Archer)
 */
export function getCharacterType() {
    return CharInfo.type[charType];
}

/**
 * Outline of our bot algorithm. For every tick:
 *  - If the bot is standing on a floor switch, do nothing
 *  - If the bot is not near the player, move within range of the player
 *  - If an enemy is within a certain distance of a player, attack that enemy
 *  - If the switch is within a range of 30 units from the bot, move onto the switch
 */
export async function runTurn(rg) {

    if(rg.getState().sceneName !== "BossRoom") return;

    const currentPosition = rg.getBot().position;

    // if the bot is standing on a switch, then do nothing
    const floorSwitch = await rg.findEntity("FloorSwitch");
    if(floorSwitch && await rg.entityHasAttribute(floorSwitch, "isOn", true)) return;

     // if the switch is within range of 30 units from the bot, then move onto it
    if(floorSwitch && rg.MathFunctions.distanceSq(currentPosition, floorSwitch.position) < 30) {
        rg.performAction("FollowObject", {
            targetId: floorSwitch.id,
            range: 0.1
        });
        return;
    }

  // if the bot is not near the human player, then move within range of that player
    const humanPlayer = await rg.findEntity("HumanPlayer");
    if(humanPlayer && rg.MathFunctions.distanceSq(currentPosition, humanPlayer.position) > 10 ) {
        rg.performAction("FollowObject", {
            targetId: humanPlayer.id,
            range: 2
        });
        return;
    }

  // Otherwise, attack a nearby enemy if there is one
    const enemy = await rg.findNearestEntity(null, currentPosition, (entity) => { return entity.team === 1 && !entity.broken});
    if(enemy && enemy.health > 0) {
        rg.performAction("PerformSkill", {
            skillId: 1,
            targetId: enemy.id,
            xPosition: enemy.position.x,
            yPosition: enemy.position.y,
            zPosition: enemy.position.z
        });
    }
}

```
</TabItem>
<TabItem value="runTurn_abilityBot" label="Cycle through castable abilities">

```javascript
import { CharInfo } from "../bossroom";

let charType = Math.round(Math.random() * 1000000) % 4;

/**
 * Defines the type of character that the game should use for this bot
 */
export function getCharacterType() {
    return CharInfo.type[charType];
}

/**
 * Entrypoint into the bot logic
 */
export async function runTurn(rg) {
    // only activate abilities if we're on the game scene
    if (rg.getState().sceneName !== "BossRoom") return;

    // select 1 ability per update
    await selectAbility(rg);
}

/**
 * Returns the ID of the next ability in our rotation
 */
function getNextAbility() {
    const abilities = CharInfo.abilities[charType];
    const abilityIndex = CURRENT_ABILITY % abilities.length;
    return abilities[abilityIndex];
}

/**
 * Returns a number corresponding to who this ability needs to target
 * -1 -> No target
 *  0 -> Targets an Ally
 *  1 -> Targets an Enemy
 *  2 -> AOE
 */
function getTargetType() {
    const abilities = CharInfo.abilities[charType];
    const abilityIndex = CURRENT_ABILITY % abilities.length;
    return CharInfo.abilityTargets[charType][abilityIndex];
}

let CURRENT_ABILITY = 0;

/**
 * Selects an ability for this character, then queues it as an action
 */
async function selectAbility(rg) {

    const ability = getNextAbility();
    if(!rg.entityHasAttribute(rg.getBot(), ["isOnCooldown", `ability${ability}Available`], true)) {
        // this ability is still on cooldown
        return;
    }

    const targetType = getTargetType();
    let currentTarget;

    if (targetType === -1) 
    {
        // No target needed
        currentTarget = null;
    } 
    else if (targetType === 1) {
        // The ability requires an enemy -> find the nearest one.
        const randomEnemy = await rg.findNearestEntity(null, null, (entity) => { return entity.team === 1 && !entity.broken } )
        if (randomEnemy) {
            currentTarget = randomEnemy;
        } else {
            return;
        }
    } 
    else {
        // Otherwise, this ability either targets an ally or needs an aoe position - select the closest ally
        currentTarget = await rg.findNearestEntity(null, null, (entity) => { return entity.team === 0 });
    }
  
    rg.performAction("PerformSkill", {
        skillId: ability,
        targetId: currentTarget?.id,
        xPosition: currentTarget?.position?.x,
        yPosition: currentTarget?.position?.y,
        zPosition: currentTarget?.position?.z
    });

    CURRENT_ABILITY++;
}

```

</TabItem>

<TabItem value="runTurn_menuBot" label="Click buttons to start the game">

```javascript

import { CharInfo } from "../bossroom";

/**
 * Defines the type of character that the game should use for this bot.
 */
export function getCharacterType() {
    return CharInfo.type[1]; // fixed to rogue character
}

/**
 * One of ...
 * MANAGED - Server disconnects/ends bot on match/game-scene teardown
 * PERSISTENT - Bot is responsible for disconnecting / ending itself
 */
export function getBotLifecycle() {
    return 'PERSISTENT';
}

/**
 * @returns {boolean} true if I'm an in-game character, or false if I'm an invisible navigator/observer/etc.
 */
export function isSpawnable() {
    return false;
}

/**
 * Let server know if i have finished my processing
 * @returns {boolean} true if done processing and ready to be torn down
 */
export function isComplete() {
    return isFinished;
}


// flags for clicking the 6 buttons we need to click to start the game
let stateFlags = {
    "RGHostButton": false,
    "StartWithRGButton": false,
    "SelectProfileButton": false,
    "ProfileMenuButton": false,
    "ReadyButton": false,
    "Seat7Button": false,
}

let isFinished = false;
let playedGame = false;

export async function runTurn(rg) {

    const currentScene = rg.getState().sceneName;
    if(playedGame && currentScene !== "BossRoom") {
        // we played and finished the match
        isFinished = true;
        return;
    }

    switch (currentScene) {
        case "MainMenu":
            const hostButton = await getInteractableButton("RGHostButton");
            if (hostButton && stateFlags["StartWithRGButton"] && !stateFlags["RGHostButton"]) {
                rg.performAction("ClickButton", {targetId: hostButton.id});
                stateFlags["RGHostButton"] = true
            }

            const startButton = await getInteractableButton("StartWithRGButton");
            if (startButton && stateFlags["SelectProfileButton"] && !stateFlags["StartWithRGButton"]) {
                rg.performAction("ClickButton", {targetId: startButton.id});
                stateFlags["StartWithRGButton"] = true
            }

            const selectProfileButton = await getInteractableButton("SelectProfileButton");
            if (selectProfileButton && stateFlags["ProfileMenuButton"] && !stateFlags["SelectProfileButton"]) {
                rg.performAction("ClickButton", {targetId: selectProfileButton.id});
                stateFlags["SelectProfileButton"] = true
            }

            const profileMenuButton = await getInteractableButton("ProfileMenuButton");
            if (profileMenuButton && !stateFlags["ProfileMenuButton"]) {
                rg.performAction("ClickButton", {targetId: profileMenuButton.id});
                stateFlags["ProfileMenuButton"] = true
            }
            break;
        case "CharSelect":
            const readyButton = await getInteractableButton("ReadyButton");
            if (readyButton && stateFlags["Seat7Button"] && !stateFlags["ReadyButton"]) {
                rg.performAction("ClickButton", {targetId: readyButton.id});
                stateFlags["ReadyButton"] = true
            }

            const seat7Button = await getInteractableButton("Seat7Button");
            if (seat7Button && !stateFlags["Seat7Button"]) {
                rg.performAction("ClickButton", {targetId: seat7Button.id});
                stateFlags["Seat7Button"] = true
            }
            break;
        case "BossRoom":
            playedGame = true;
            const GameHUDStartButton = await getInteractableButton("GameHUDStartButton");
            if (GameHUDStartButton && stateFlags["CheatsCancelButton"] && !stateFlags["GameHUDStartButton"]) {
                rg.performAction("ClickButton", {targetId: GameHUDStartButton.id});
                stateFlags["GameHUDStartButton"] = true
            }

            const CheatsCancelButton = await getInteractableButton("CheatsCancelButton");
            if (CheatsCancelButton && !stateFlags["CheatsCancelButton"]) {
                rg.performAction("ClickButton", {targetId: CheatsCancelButton.id});
                stateFlags["CheatsCancelButton"] = true
            }
            break;
        default:
            isFinished = true;
    }

}

async function getInteractableButton(buttonName) {
    const button = await rg.findEntity(buttonName);
    if (button && await rg.entityHasAttribute(button, "interactable", true)) {
        return button;
    }
    return null;
}

```

</TabItem>
</Tabs>


### `getState(id: number = null);`

Returns a complete state object including the current state of all registered entities

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`id` | `number` | `null` | Return state information for a specific state entity

#### Return Value
Returns information about the current state

#### Examples

```javascript

// get all information about the current state
const fullState = rg.getState();

// get the current state of a known entity
const mascot = await rg.findEntity("Williward");
...
const objectState = rg.getState(mascot.id); 

```

### `getBot();`

Returns the current state information for this bot.  
Synonymous with `rg.getState(rg.playedId)`

#### Arguments
None

#### Return Value
Returns the current state information for this bot

#### Examples

```javascript

const myBot = rg.getBot();

```

### `complete()`;

Flags the current bot as complete (see [isComplete](./creating-bots#iscomplete))

#### Arguments
None

#### Return Value
No return value

#### Examples

```javascript

rg.complete();

```

### `performAction(actionName: string, args: object | null);`

Queues an action that the bot should perform. Action names are freeform strings and must correspond to the name of one of your defined `RGActions`.
Actions do not necessarily start executing the same tick that they were queued.  

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`actionName` | `string` | | The name of an action, as defined by its corresponding `RGAction`
`args` | `object` | | Any arguments that should be passed to the `RGAction`

#### Return Value
No return value

#### Examples

<Tabs>
<TabItem value="performAction_simple" label="Open a Door" default>

```javascript

const door = await rg.findEntity("Door");
rg.performAction("OpenDoor", { targetId: door.id });

```

</TabItem>
<TabItem value="performAction_arguments" label="Equip a sword">

```javascript

const bot = rg.getBot();
if(!await rg.entityHasAttribute(bot, "equippedItem", "sword")) {
    rg.performAction("EquipItem", { 
        targetId: bot.id,
        itemName: "sword",
        slot: "mainHand" 
    });
}

```
</TabItem>
</Tabs>

### `findEntity(objectType: string);`

Find an entity with the given Object Type in the game state.
This method should be used when only one entity with the given Object Type is expected to exist in the state,
or when any entity with this Object Type will satisfy the scenario.
For more control over finding specific entities in the game state, see [getState](./creating-bots#getstate) and [findNearestEntity](./creating-bots#findnearestentity).

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`objectType` | `string` | | The objectType to search for, as defined by the entity's corresponding `RGState`

#### Return Value
Promise&lt;object | null&gt;

#### Examples


```javascript

const door = await rg.findEntity("Door");
const humanPlayer = await rg.findEntity("HumanPlayer");
const areaBoss = await rg.findEntity("Boss");

```

### `findNearestEntity(objectType: string | null, position: object = null, filterFunc: function = (entity) => true);`

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`objectType` | `string` &#124; `null` | | Optionally filter entities by type 
`position` | `object` | The bot's current position | The position to measure distance from
`filterFunc` | `function` | (entity) => true | Optionally filter entities to find 

#### Return Value
Promise&lt;object | null&gt;

#### Examples

<Tabs>
<TabItem value="findNearestEntity_default" label="No Filter" default>

```javascript

const williward = await rg.findNearestEntity("Williward");
const enemyNearestToWilliward = await rg.findNearestEntity("Enemy", williward.position);

```

</TabItem>
<TabItem value="findNearestEntity_filtered" label="Filter">

```javascript

const patrolPoint = await rg.findEntity("PatrolPoint");
const guardOnPatrol = await rg.findNearestEntity("Guard", patrolPoint.position, (entity) => { return !entity.isAsleep });

```

</TabItem>
</Tabs>

### `entityExists(entity: object | number | string);`

Return whether the given entity exists.
The `entity` argument can be a reference to a previously-existing entity, its id, or an Object Type.
If this is an Object Type, will return true if _any_ entities with this ObjectType exist. 

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`entity` | `object` &#124; `number` &#124; `string` | | The entity, its id, or an Object Type. If this is an Object Type, will return true if _any_ entities with this ObjectType exist. 

#### Return Value
Promise&lt;boolean&gt;

#### Examples

<Tabs>
<TabItem value="entityExists_entity" label="Entity" default>

```javascript

const entity = await rg.findEntity("Williward");
... 
const exists = await rg.entityExists(entity);

```

</TabItem>
<TabItem value="entityExists_id" label="Entity ID">

```javascript

const entity = await rg.findEntity("Williward");
... 
const exists = await rg.entityExists(entity.id);

```

</TabItem>
<TabItem value="entityExists_objectType" label="Object Type">

```javascript

const exists = await rg.entityExists("Williward");

```

</TabItem>
</Tabs>

### `entityDoesNotExist(entity: object | number | string);`

Return whether the given entity does not exist.
The `entity` argument can be a reference to a previously-existing entity, its id, or an Object Type.
If this is an Object Type, will return true if _no_ entities with this ObjectType exist. 

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`entity` | `object` &#124; `number` &#124; `string` | | The entity, its id, or an Object Type. If this is an Object Type, will return true if _no_ entities with this ObjectType exist. 

#### Return Value
Promise&lt;boolean&gt;

#### Examples

<Tabs>
<TabItem value="entityDoesNotExist_entity" label="Entity" default>

```javascript

const staleEntity = await rg.findEntity("Williward");
... 
const exists = await rg.entityDoesNotExist(staleEntity);

```

</TabItem>
<TabItem value="entityDoesNotExist_id" label="Entity ID">

```javascript

const staleEntity = await rg.findEntity("Williward");
... 
const exists = await rg.entityDoesNotExist(staleEntity.id);

```

</TabItem>
<TabItem value="entityDoesNotExist_objectType" label="Object Type">

```javascript

const exists = await rg.entityDoesNotExist("Williward");

```

</TabItem>
</Tabs>


### `entityHasAttribute(targetEntity: object, stateAttribute: string | string[], expectedValue: any);`

Return whether the entity in the game state has the expected value for one of its attributes.

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`targetEntity` | `object` | | The entity
`stateAttribute` | `string` &#124; `string[]` | | The name of the attribute key, or an array of keys for nested attributes
`expectedValue` | `any` | | The expected value for the entity's state attribute

#### Return Value
Promise&lt;boolean&gt;

#### Examples

<Tabs>
<TabItem value="entityHasAttribute_entity" label="Attribute" default>

```javascript

const entity = await rg.findEntity("Williward");
if(await rg.entityHasAttribute(entity, "color", "teal")) {
    console.log("Williward is looking good!")
}

```

</TabItem>
<TabItem value="entityHasAttribute_id" label="Nested Attribute">

```javascript

const entity = await rg.findEntity("Boss");
if(await rg.entityHasAttribute(entity, ["healthObject", "currentHealth"], 1000)) {
    console.log("The boss is at full health")
}

```
</TabItem>
</Tabs>


## Validation Testing with Bots

Regression Games bots support an `automatedTestMode` which can be used to test game components and behaviors 
and validate changes in the game state in response to character actions. To enable this mode, add the following line to your bot configuration:

```javascript
rg.automatedTestMode = true;
```

:::tip
This mode is useful for automated testing where commands must be issued in a deterministic order, 
and where the game state must meet the explicit expectations of one command before the next commend is executed or else the scenario will fail.
:::

:::caution
This mode should not be used for bots intended to make dynamic decisions based on the current game state, 
where a falsey result from a command should not cause the entire scenario to fail. 
:::

This mode is similar in practice to the default [dynamic bot mode](./creating-bots#defining-dynamic-bot-behaviors) with two important distinctions:
1. Your bot logic will be implemented within a `configureBot` method rather than `runTurn`. 
`configureBot` is invoked once after the bot connects and will run to completion rather than being invoked once per tick interval. 
2. Commands act as assertions. When a command is executed, it automatically waits and retries until the game state meets its expectation. 
If the expectation hasn't been met after a default timeout then the command, and by extension the scenario, will fail.
For example, the command `rg.findEntity("MyEntity")` in the default dynamic-bot mode will return a matching entity or null based on the current tick's game state,
but the same command in `automatedTestMode` may check the state across several tick intervals until a matching entity is found, or else the command will fail.

<Tabs>
<TabItem value="configureBot_abilityBot" label="Cycle through castable abilities" default>

```javascript

import { CharInfo } from "../bossroom";

let charType = 0; // Healer
let isFinished = false;

/**
 * Defines the type of character that the game should use for this bot.
 */
export function getCharacterType() {
    return CharInfo.type[charType]; 
}

/**
 * One of ...
 * MANAGED - Server disconnects/ends bot on match/game-scene teardown
 * PERSISTENT - Bot is responsible for disconnecting / ending itself
 */
export function getBotLifecycle() {
    return 'PERSISTENT';
}

/**
 * @returns {boolean} true if I'm an in-game character, or false if I'm an invisible navigator/observer/etc.
 */
export function isSpawnable() {
    return true;
}

export function isComplete() {
    return isFinished;
}

export async function configureBot(rg) {
    
    rg.automatedTestMode = true;

    // validate that we're in the game
    await rg.waitForScene("BossRoom");

    // find the closest human player and use a heal ability on them
    let target = await rg.findNearestEntity("HumanPlayer");
    await rg.entityExists(target);

    let skillId = CharInfo.abilities[charType][1]
    rg.performAction("PerformSkill", {
        skillId: skillId,
        targetId: target.id,
        xPosition: target.position.x,
        yPosition: target.position.y,
        zPosition: target.position.z
    })

    // validate that the heal recovers from cooldown
    await rg.entityHasAttribute(rg.getBot(), ["isOnCooldown", `ability${skillId}Available`], true); 


    // find the closest enemy and use the basic attack until it dies
    // measure from the position of a known imp, 
    // so the character doesn't try to attack through a wall
    target = await rg.findNearestEntity("Imp", { x: -3.95, y: 0.0, z: -15.5 });
    await rg.entityExists(target);
    await rg.entityHasAttribute(target, "health", 15);

    // approach the entity
    rg.performAction("FollowObject", {
        targetId: target.id,
        range: 5,
    });

    // queue three attacks
    // each one should do 5 damage
    skillId = CharInfo.abilities[charType][0];
    const args = {
        skillId: skillId,
        targetId: target.id,
        xPosition: target.position.x,
        yPosition: target.position.y,
        zPosition: target.position.z
    }
    rg.performAction("PerformSkill", args)
    await rg.entityHasAttribute(target, "health", 10);

    rg.performAction("PerformSkill", args)
    await rg.entityHasAttribute(target, "health", 5);

    rg.performAction("PerformSkill", args)
    await rg.entityDoesNotExist(target);

    isFinished = true;
}

```

</TabItem>

<TabItem value="runTurn_menuBot" label="Click buttons to start the game">

```javascript

import { CharInfo } from "../bossroom";

let isFinished = false;

/**
 * Defines the type of character that the game should use for this bot.
 */
export function getCharacterType() {
    // fixed to rogue character, 
    // but the character type doesn't influence this scenario
    // because this bot is not spawnable.
    return CharInfo.type[1]; 
}

/**
 * One of ...
 * MANAGED - Server disconnects/ends bot on match/game-scene teardown
 * PERSISTENT - Bot is responsible for disconnecting / ending itself
 */
export function getBotLifecycle() {
    return 'PERSISTENT';
}

/**
 * @returns {boolean} true if I'm an in-game character, or false if I'm an invisible navigator/observer/etc.
 */
export function isSpawnable() {
    return false;
}

/**
 * Let server know if I have finished my processing
 * @returns {boolean} true if done processing and ready to be torn down
 */
export function isComplete() {
    return isFinished;
}

/**
 * Start running my test scenario
 */
export async function configureBot(rg) {

    rg.automatedTestMode = true;

    // validate we're on the main menu
    await rg.waitForScene("MainMenu");

    // get to the character select screen
    const profileMenuButton = await rg.findEntity("ProfileMenuButton");
    await rg.entityHasAttribute(profileMenuButton, "interactable", true);
    rg.performAction("ClickButton", {targetId: profileMenuButton.id});

    const selectProfileButton = await rg.findEntity("SelectProfileButton");
    await rg.entityHasAttribute(selectProfileButton, "interactable", true);
    rg.performAction("ClickButton", {targetId: selectProfileButton.id});

    const startWithRGButton = await rg.findEntity("StartWithRGButton");
    await rg.entityHasAttribute(startWithRGButton, "interactable", true);
    rg.performAction("ClickButton", {targetId: startWithRGButton.id});

    const rgHostButton = await rg.findEntity("RGHostButton");
    await rg.entityHasAttribute(rgHostButton, "interactable", true);
    rg.performAction("ClickButton", {targetId: rgHostButton.id});


    // now we should be at character select
    await rg.entityDoesNotExist(profileMenuButton);
    await rg.entityDoesNotExist(selectProfileButton);
    await rg.entityDoesNotExist(startWithRGButton);
    await rg.entityDoesNotExist(rgHostButton);
    await rg.waitForScene("CharSelect");

    // select a character and get to the game screen
    const seat7Button = await rg.findEntity("Seat7Button");
    await rg.entityHasAttribute(seat7Button, "interactable", true);
    rg.performAction("ClickButton", {targetId: seat7Button.id});

    const readyButton = await rg.findEntity("ReadyButton");
    await rg.entityHasAttribute(readyButton, "interactable", true);
    rg.performAction("ClickButton", {targetId: readyButton.id});


    // we should be in the dungeon now
    await rg.entityDoesNotExist(seat7Button);
    await rg.entityDoesNotExist(readyButton);
    await rg.waitForScene("BossRoom");

    // dismiss the help dialogs so we can start playing
    const cheatsCancelButton = await rg.findEntity("CheatsCancelButton");
    await rg.entityHasAttribute(cheatsCancelButton, "interactable", true);
    rg.performAction("ClickButton", {targetId: cheatsCancelButton.id});

    const gameHUDStartButton = await rg.findEntity("GameHUDStartButton");
    await rg.entityHasAttribute(gameHUDStartButton, "interactable", true);
    rg.performAction("ClickButton", {targetId: gameHUDStartButton.id});

    // HUD should have been dismissed, 
    // which means our buttons should also no longer be on the screen
    await rg.entityDoesNotExist(cheatsCancelButton);
    await rg.entityDoesNotExist(gameHUDStartButton);


    // we're done!
    isFinished = true;
}

```

</TabItem>
</Tabs>


### `setDefaultTimeout(timeout: number);`

Sets a default timeout in milliseconds. The validator will retry until a condition succeeds.
If this timeout is hit first, then the validator will report a failure. 

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`timeout` | `number` | | The new default timeout

#### Return Value
No return value

#### Examples

```javascript

const myBot = rg.getBot();

```

### `async waitForScene(sceneName: string);`

Wait until the current scene name matches the expected value.

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`sceneName` | `string` | | The name of the scene to wait for

#### Return Value
Promise&lt;void&gt;

#### Examples

```javascript

await rg.waitForScene("StartupScreen");
await rg.waitForScene("UpdaterSplash");
await rg.waitForScene("MainMenu")

```

