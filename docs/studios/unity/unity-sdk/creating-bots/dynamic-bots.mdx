---
sidebar_label: 'Dynamic Bots'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Defining Dynamic Bots

Your Unity integration collects state information about game objects and notifies the Bot runtime with the updated state at a fixed tick interval.
Whenever the Bot runtime receives an update, Regression Games calls the `runTurn` method. This is the entrypoint into your Bot logic for each tick.        

The following API is used to evaluate the current game state within `runTurn` and queue behaviors you've defined as `RGActions`.
Methods that filter state objects and check conditions also record results which can be loaded into the Unity Bot replay to help visualize the Bot's decison-making at each tick.  

:::tip
Dynamic Bots are useful for simulating autonomous characters whose actions will change depending on conditions in the game state.
:::

:::caution
Commands within `runTurn` interact with the game state represented by the current tick only.
This contrasts with [Validation Bots](./validation-bots), which can delay execution of commands for several ticks until expected prerequisites have been met. 
:::

<Tabs>
<TabItem value="runTurn_coopBot" label="Follow and support a human player as an NPC" default>

```javascript
import { CharInfo } from "../bossroom";

let charType = 3; // Archer

/**
 * Defines the type of character that the game should use for this Bot (in this case an Archer)
 */
export function getCharacterType() {
    return CharInfo.type[charType];
}

/**
 * Outline of our Bot algorithm. For every tick:
 *  - If the Bot is standing on a floor switch, do nothing
 *  - If the Bot is not near the player, move within range of the player
 *  - If an enemy is within a certain distance of a player, attack that enemy
 *  - If the switch is within a range of 30 units from the Bot, move onto the switch
 */
export async function runTurn(rg) {

    if(rg.getState().sceneName !== "BossRoom") return;

    const currentPosition = rg.getBot().position;

    // if the Bot is standing on a switch, then do nothing
    const floorSwitch = await rg.findEntity("FloorSwitch");
    if(floorSwitch && await rg.entityHasAttribute(floorSwitch, "isOn", true)) return;

     // if the switch is within range of 30 units from the Bot, then move onto it
    if(floorSwitch && rg.MathFunctions.distanceSq(currentPosition, floorSwitch.position) < 30) {
        rg.performAction("FollowObject", {
            targetId: floorSwitch.id,
            range: 0.1
        });
        return;
    }

  // if the Bot is not near the human player, then move within range of that player
    const humanPlayer = await rg.findEntity("HumanPlayer");
    if(humanPlayer && rg.MathFunctions.distanceSq(currentPosition, humanPlayer.position) > 10 ) {
        rg.performAction("FollowObject", {
            targetId: humanPlayer.id,
            range: 2
        });
        return;
    }

  // Otherwise, attack a nearby enemy if there is one
    const enemy = await rg.findNearestEntity(null, currentPosition, (entity) => { return entity.team === 1 && !entity.broken});
    if(enemy && enemy.health > 0) {
        rg.performAction("PerformSkill", {
            skillId: 1,
            targetId: enemy.id,
            xPosition: enemy.position.x,
            yPosition: enemy.position.y,
            zPosition: enemy.position.z
        });
    }
}
```
</TabItem>
<TabItem value="runTurn_abilityBot" label="Cycle through castable abilities">

```javascript
import { CharInfo } from "../bossroom";

let charType = Math.round(Math.random() * 1000000) % 4;

/**
 * Defines the type of character that the game should use for this Bot
 */
export function getCharacterType() {
    return CharInfo.type[charType];
}

/**
 * Entrypoint into the Bot logic
 */
export async function runTurn(rg) {
    // only activate abilities if we're on the game scene
    if (rg.getState().sceneName !== "BossRoom") return;

    // select 1 ability per update
    await selectAbility(rg);
}

/**
 * Returns the ID of the next ability in our rotation
 */
function getNextAbility() {
    const abilities = CharInfo.abilities[charType];
    const abilityIndex = CURRENT_ABILITY % abilities.length;
    return abilities[abilityIndex];
}

/**
 * Returns a number corresponding to who this ability needs to target
 * -1 -> No target
 *  0 -> Targets an Ally
 *  1 -> Targets an Enemy
 *  2 -> AOE
 */
function getTargetType() {
    const abilities = CharInfo.abilities[charType];
    const abilityIndex = CURRENT_ABILITY % abilities.length;
    return CharInfo.abilityTargets[charType][abilityIndex];
}

let CURRENT_ABILITY = 0;

/**
 * Selects an ability for this character, then queues it as an action
 */
async function selectAbility(rg) {

    const ability = getNextAbility();
    if(!rg.entityHasAttribute(rg.getBot(), ["isOnCooldown", `ability${ability}Available`], true)) {
        // this ability is still on cooldown
        return;
    }

    const targetType = getTargetType();
    let currentTarget;

    if (targetType === -1) 
    {
        // No target needed
        currentTarget = null;
    } 
    else if (targetType === 1) {
        // The ability requires an enemy -> find the nearest one.
        const randomEnemy = await rg.findNearestEntity(null, null, (entity) => { return entity.team === 1 && !entity.broken } )
        if (randomEnemy) {
            currentTarget = randomEnemy;
        } else {
            return;
        }
    } 
    else {
        // Otherwise, this ability either targets an ally or needs an aoe position - select the closest ally
        currentTarget = await rg.findNearestEntity(null, null, (entity) => { return entity.team === 0 });
    }
  
    rg.performAction("PerformSkill", {
        skillId: ability,
        targetId: currentTarget?.id,
        xPosition: currentTarget?.position?.x,
        yPosition: currentTarget?.position?.y,
        zPosition: currentTarget?.position?.z
    });

    CURRENT_ABILITY++;
}
```

</TabItem>

<TabItem value="runTurn_menuBot" label="Click buttons to start the game">

```javascript
import { CharInfo } from "../bossroom";

/**
 * Defines the type of character that the game should use for this Bot.
 */
export function getCharacterType() {
    return CharInfo.type[1]; // fixed to rogue character
}

/**
 * One of ...
 * MANAGED - Server disconnects/ends Bot on match/game-scene teardown
 * PERSISTENT - Bot is responsible for disconnecting / ending itself
 */
export function getBotLifecycle() {
    return 'PERSISTENT';
}

/**
 * @returns {boolean} true if I'm an in-game character, or false if I'm an invisible navigator/observer/etc.
 */
export function isSpawnable() {
    return false;
}

/**
 * Let server know if i have finished my processing
 * @returns {boolean} true if done processing and ready to be torn down
 */
export function isComplete() {
    return isFinished;
}


// flags for clicking the 6 buttons we need to click to start the game
let stateFlags = {
    "RGHostButton": false,
    "StartWithRGButton": false,
    "SelectProfileButton": false,
    "ProfileMenuButton": false,
    "ReadyButton": false,
    "Seat7Button": false,
}

let isFinished = false;
let playedGame = false;

export async function runTurn(rg) {

    const currentScene = rg.getState().sceneName;
    if(playedGame && currentScene !== "BossRoom") {
        // we played and finished the match
        isFinished = true;
        return;
    }

    switch (currentScene) {
        case "MainMenu":
            const hostButton = await getInteractableButton("RGHostButton");
            if (hostButton && stateFlags["StartWithRGButton"] && !stateFlags["RGHostButton"]) {
                rg.performAction("ClickButton", {targetId: hostButton.id});
                stateFlags["RGHostButton"] = true
            }

            const startButton = await getInteractableButton("StartWithRGButton");
            if (startButton && stateFlags["SelectProfileButton"] && !stateFlags["StartWithRGButton"]) {
                rg.performAction("ClickButton", {targetId: startButton.id});
                stateFlags["StartWithRGButton"] = true
            }

            const selectProfileButton = await getInteractableButton("SelectProfileButton");
            if (selectProfileButton && stateFlags["ProfileMenuButton"] && !stateFlags["SelectProfileButton"]) {
                rg.performAction("ClickButton", {targetId: selectProfileButton.id});
                stateFlags["SelectProfileButton"] = true
            }

            const profileMenuButton = await getInteractableButton("ProfileMenuButton");
            if (profileMenuButton && !stateFlags["ProfileMenuButton"]) {
                rg.performAction("ClickButton", {targetId: profileMenuButton.id});
                stateFlags["ProfileMenuButton"] = true
            }
            break;
        case "CharSelect":
            const readyButton = await getInteractableButton("ReadyButton");
            if (readyButton && stateFlags["Seat7Button"] && !stateFlags["ReadyButton"]) {
                rg.performAction("ClickButton", {targetId: readyButton.id});
                stateFlags["ReadyButton"] = true
            }

            const seat7Button = await getInteractableButton("Seat7Button");
            if (seat7Button && !stateFlags["Seat7Button"]) {
                rg.performAction("ClickButton", {targetId: seat7Button.id});
                stateFlags["Seat7Button"] = true
            }
            break;
        case "BossRoom":
            playedGame = true;
            const GameHUDStartButton = await getInteractableButton("GameHUDStartButton");
            if (GameHUDStartButton && stateFlags["CheatsCancelButton"] && !stateFlags["GameHUDStartButton"]) {
                rg.performAction("ClickButton", {targetId: GameHUDStartButton.id});
                stateFlags["GameHUDStartButton"] = true
            }

            const CheatsCancelButton = await getInteractableButton("CheatsCancelButton");
            if (CheatsCancelButton && !stateFlags["CheatsCancelButton"]) {
                rg.performAction("ClickButton", {targetId: CheatsCancelButton.id});
                stateFlags["CheatsCancelButton"] = true
            }
            break;
        default:
            isFinished = true;
    }

}

async function getInteractableButton(buttonName) {
    const button = await rg.findEntity(buttonName);
    if (button && await rg.entityHasAttribute(button, "interactable", true)) {
        return button;
    }
    return null;
}
```

</TabItem>
</Tabs>


## Variables

### `playerId`

The ID of this Bot in the game state.

### `name`

The given name of the connected Bot

### `characterType`

A freeform string defining this Bot's character configuration. See [isSpawnable()](./configuration#isSpawnable) and [getCharacterConfig()](./configuration#getCharacterConfig)


## Methods

### `getState(id: number = null);`

Returns a complete state object including the current state of all registered entities

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`id` | `number` | `null` | Return state information for a specific state entity

#### Return Value
Returns information about the current state

#### Examples

```javascript
// get all information about the current state
const fullState = rg.getState();

// get the current state of a known entity
const mascot = await rg.findEntity("Williward");
...
const objectState = rg.getState(mascot.id); 
```

### `getBot();`

Returns the current state information for this Bot.  
Synonymous with `rg.getState(rg.playedId)`

#### Arguments
None

#### Return Value
Returns the current state information for this Bot

#### Examples

```javascript
const myBot = rg.getBot();
```

### `complete()`;

Flags the current Bot as complete (see [isComplete()](./configuration#isComplete))

#### Arguments
None

#### Return Value
No return value

#### Examples

```javascript
rg.complete();
```

### `performAction(actionName: string, args: object | null);`

Queues an action that the Bot should perform. Action names are freeform strings and must correspond to the name of one of your defined `RGActions`.
Actions do not necessarily start executing the same tick that they were queued.  

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`actionName` | `string` | | The name of an action, as defined by its corresponding `RGAction`
`args` | `object` | | Any arguments that should be passed to the `RGAction`

#### Return Value
No return value

#### Examples

<Tabs>
<TabItem value="performAction_simple" label="Open a Door" default>

```javascript
const door = await rg.findEntity("Door");
rg.performAction("OpenDoor", { targetId: door.id });
```

</TabItem>
<TabItem value="performAction_arguments" label="Equip a sword">

```javascript
const bot = rg.getBot();
if(!await rg.entityHasAttribute(bot, "equippedItem", "sword")) {
    rg.performAction("EquipItem", { 
        targetId: bot.id,
        itemName: "sword",
        slot: "mainHand" 
    });
}
```
</TabItem>
</Tabs>

### `findEntity(objectType: string);`

Find an entity with the given Object Type in the game state.
This method should be used when only one entity with the given Object Type is expected to exist in the state,
or when any entity with this Object Type will satisfy the scenario.
For more control over finding specific entities in the game state, see [getState](./dynamic-bots#getState) and [findNearestEntity](./dynamic-bots#findNearestEntity).

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`objectType` | `string` | | The objectType to search for, as defined by the entity's corresponding `RGState`

#### Return Value
Promise&lt;object | null&gt;

#### Examples


```javascript
const door = await rg.findEntity("Door");
const humanPlayer = await rg.findEntity("HumanPlayer");
const areaBoss = await rg.findEntity("Boss");
```

### `findNearestEntity(objectType: string | null, position: object = null, filterFunc: function = (entity) => true);`

Finds the closest entity to the given position.

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`objectType` | `string` &#124; `null` | | Optionally filter entities by type 
`position` | `object` | The Bot's current position | The position to measure distance from
`filterFunc` | `function` | (entity) => true | Optionally filter entities to find 

#### Return Value
Promise&lt;object | null&gt;

#### Examples

<Tabs>
<TabItem value="findNearestEntity_default" label="No Filter" default>

```javascript
const williward = await rg.findNearestEntity("Williward");
const enemyNearestToWilliward = await rg.findNearestEntity("Enemy", williward.position);
```

</TabItem>
<TabItem value="findNearestEntity_filtered" label="Filter">

```javascript
const patrolPoint = await rg.findEntity("PatrolPoint");
const guardOnPatrol = await rg.findNearestEntity("Guard", patrolPoint.position, (entity) => { return !entity.isAsleep });
```

</TabItem>
</Tabs>

### `entityExists(entity: object | number | string);`

Return whether the given entity exists.
The `entity` argument can be a reference to a previously-existing entity, its id, or an Object Type.
If this is an Object Type, will return true if _any_ entities with this ObjectType exist. 

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`entity` | `object` &#124; `number` &#124; `string` | | The entity, its id, or an Object Type. If this is an Object Type, will return true if _any_ entities with this ObjectType exist. 

#### Return Value
Promise&lt;boolean&gt;

#### Examples

<Tabs>
<TabItem value="entityExists_entity" label="Entity" default>

```javascript
const entity = await rg.findEntity("Williward");
... 
const exists = await rg.entityExists(entity);
```

</TabItem>
<TabItem value="entityExists_id" label="Entity ID">

```javascript
const entity = await rg.findEntity("Williward");
... 
const exists = await rg.entityExists(entity.id);
```

</TabItem>
<TabItem value="entityExists_objectType" label="Object Type">

```javascript
const exists = await rg.entityExists("Williward");
```

</TabItem>
</Tabs>

### `entityDoesNotExist(entity: object | number | string);`

Return whether the given entity does not exist.
The `entity` argument can be a reference to a previously-existing entity, its id, or an Object Type.
If this is an Object Type, will return true if _no_ entities with this ObjectType exist. 

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`entity` | `object` &#124; `number` &#124; `string` | | The entity, its id, or an Object Type. If this is an Object Type, will return true if _no_ entities with this ObjectType exist. 

#### Return Value
Promise&lt;boolean&gt;

#### Examples

<Tabs>
<TabItem value="entityDoesNotExist_entity" label="Entity" default>

```javascript
const staleEntity = await rg.findEntity("Williward");
... 
const exists = await rg.entityDoesNotExist(staleEntity);
```

</TabItem>
<TabItem value="entityDoesNotExist_id" label="Entity ID">

```javascript
const staleEntity = await rg.findEntity("Williward");
... 
const exists = await rg.entityDoesNotExist(staleEntity.id);
```

</TabItem>
<TabItem value="entityDoesNotExist_objectType" label="Object Type">

```javascript
const exists = await rg.entityDoesNotExist("Williward");
```

</TabItem>
</Tabs>


### `entityHasAttribute(targetEntity: object, stateAttribute: string | string[], expectedValue: any);`

Return whether the entity in the game state has the expected value for one of its attributes.

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`targetEntity` | `object` | | The entity
`stateAttribute` | `string` &#124; `string[]` | | The name of the attribute key, or an array of keys for nested attributes
`expectedValue` | `any` | | The expected value for the entity's state attribute

#### Return Value
Promise&lt;boolean&gt;

#### Examples

<Tabs>
<TabItem value="entityHasAttribute_entity" label="Attribute" default>

```javascript
const entity = await rg.findEntity("Williward");
if(await rg.entityHasAttribute(entity, "color", "teal")) {
    console.log("Williward is looking good!")
}
```

</TabItem>
<TabItem value="entityHasAttribute_id" label="Nested Attribute">

```javascript
const entity = await rg.findEntity("Boss");
if(await rg.entityHasAttribute(entity, ["healthObject", "currentHealth"], 1000)) {
    console.log("The boss is at full health")
}
```
</TabItem>
</Tabs>


