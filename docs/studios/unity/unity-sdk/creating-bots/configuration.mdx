---
sidebar_label: 'Configuration'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Configuration

Regression Games Bots are flexible and highly customizable.
Bots can simulate players, function as NPCs, interact with menus and UIs, validate gameplay, and more.
Bots run in the Regression Games runtime and connect to your game via socket connections initiated from your Unity integration.
Each Bot receives the current game state at a regular interval and uses our Javascript API to analyze the state, 
make decisions, and interact with game elements.

## Project Setup

A Bot project is structured as an npm package.

First, install [Node.js](https://nodejs.org/en/download) version 16.x (which can be checked by running `node -v`). 
You can use [nvm](https://github.com/nvm-sh/nvm) for managing multiple Node versions installed on a single machine. 

To create your project and install node dependencies, create a new directory and navigate to it, then run the following commands:

```
npm init -y
npm i @types/node node-fetch rg-match-info
```

Finally, create an `index.js` file at your project root. 
This is where you'll implement methods to define the Bot and its behaviors as described in the following sections.  

## Bot Configuration

The first step to writing your Javascript Bot is configuring the Bot instance.
Implement the following methods to define how your Unity Integration should spawn and terminate this Bot.  

### `isSpawnable();`

Specifies whether this Bot should be represented by a visible GameObject.
Bots that simulate players or NPCs are generally spawnable, while Bots that interact with menus, 
represent environmental hazards, observe the game state without interaction, etc. are not.

#### Arguments
None

#### Return Value
boolean (Default `true`)

#### Examples

```javascript
isSpawnable() {
    return true;
}
```


### `getCharacterConfig();`

For spawnable Bots. 
Provides an object containing character configurations to help seat your Bot as the appropriate class/prefab/etc.
This is a freeform object to be interpreted by your game's implementation of the `RGBotSpawnManager.SeatPlayer` and `RGSpawnManager.SpawnBot` interfaces.

#### Arguments
None

#### Return Value
Javascript Object

#### Examples

<Tabs>
<TabItem value="character_config_simple" label="Simple definition" default>

```javascript
getCharacterConfig() {
    return {
        "type" : "Mage"
    }
}
```

</TabItem>
<TabItem value="character_type_freeform" label="Complex definition" default>

```javascript
getCharacterConfig() {
    return {
        "class": "Warrior",
        "subClass": "Reaver",
        "startingEquipment": {
            "mainHand": "Sword",
            "offHand": "Sword"
        },
        "spawn": "BlueTower",
        "maxHP": "50"
    }
}
```

</TabItem>
</Tabs>


### `getBotLifeCycle();`

Bots can be either `MANAGED` or `PERSISTENT`.
A `MANAGED` Bot will automatically disconnect when `RGBotServerListener.GetInstance()?.StopGame()` is called from the Unity Integration.
A `PERSISTENT` Bot must either terminate itself (see [isComplete](./configuration#isComplete)) when its tasks are complete or be terminated manually from the RG Overlay.

#### Arguments
None

#### Return Value
One of `"MANAGED"` or `"PERSISTENT"`.

#### Examples
<Tabs>
<TabItem value="managed_bot" label="Managed" default>

```javascript
getBotLifeCycle() {
    return 'MANAGED'
}
```

</TabItem>
<TabItem value="persistent_bot" label="Persistent" default>

```javascript
getBotLifeCycle() {
    return 'PERSISTENT'
}
```

</TabItem>
</Tabs>


### `isComplete();`

Allows a Bot to disconnect itself from the game before the Unity integration would normally signal Bots to disconnect.
Returning `true` from this method will stop Bot execution and send a teardown notification to your game for this Bot.
This is particularly useful for [Validation Bots](./validation-bots), which execute a specific set of commands and then are considered to have 'completed' their tasks.

#### Arguments
None

#### Return Value
boolean

#### Examples

```javascript
let tasksComplete = false;
isComplete() {
    return tasksComplete;
}
```
