---
sidebar_label: 'Validation Bots'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Defining Bots for Validation Testing

Regression Games Bots support an `automatedTestMode` which can be used to test GameObject behaviors 
and validate changes in the game state in response to character actions. To enable this mode, add the following line to your Bot configuration:

```javascript
rg.automatedTestMode = true;
```

:::tip
This mode is useful for automated testing where commands must be issued in a deterministic order, 
and where the game state must meet the explicit expectations of one command before the next command is executed or else the scenario will fail.
:::

:::caution
This mode should not be used for Bots intended to make dynamic decisions based on the current game state, 
where a falsey result from a command should not cause the entire scenario to fail. 
:::

This mode shares all of the APIs of [PlayTest Bots](./playtest-bots), with two important distinctions:
1. Bot logic is implemented within a `configureBot` method rather than `runTurn`. 
`configureBot` is invoked once after the Bot connects and will run to completion rather than being invoked repeatedly over the lifetime of the Bot. 
Like `runTurn`, `configureBot` accepts an `rg` object for access to the Regression Games API.
2. Commands act as assertions. When a command is executed, it automatically waits and retries until the game state meets expectations. 
If an expectation hasn't been met before a default timeout then the command, and by extension the scenario, will fail.
For example, the command `rg.findEntity("MyEntity")` for a PlayTest Bot will return the matching entity or null based on the current tick's game state,
but the same command in `automatedTestMode` will check the state across several tick intervals until a matching entity is found, or else the command will fail.

<Tabs>
<TabItem value="configureBot_abilityBot" label="Cycle through castable abilities" default>

```javascript
let isFinished = false;

/**
 * Defines the type of character that the game should use for this Bot.
 */
export function getCharacterConfig() {
    return {
        characterClass: "HEALER"
    }
}

/**
 * One of ...
 * MANAGED - Server disconnects/ends Bot on match/game-scene teardown
 * PERSISTENT - Bot is responsible for disconnecting / ending itself
 */
export function getBotLifecycle() {
    return 'PERSISTENT';
}

/**
 * @returns {boolean} true if I'm an in-game character, or false if I'm an invisible navigator/observer/etc.
 */
export function isSpawnable() {
    return true;
}

export function isComplete() {
    return isFinished;
}

export async function configureBot(rg) {
    
    rg.automatedTestMode = true;

    // validate that we're in the game
    await rg.waitForScene("Dungeon");

    // find the closest human player and use a heal ability on them
    let target = await rg.findNearestEntity("HumanPlayer");
    await rg.entityExists(target);

    rg.performAction("Heal", {
        targetId: target.id,
        position: target.position
    })

    // validate that the heal recovers from cooldown
    await rg.entityHasAttribute(rg.getBot(), ["abilityAvailable", "Heal"], true); 

    // find the closest enemy and use a basic attack until it dies.
    // measure from the position of a known imp, 
    // so the character doesn't try to attack through a wall
    target = await rg.findNearestEntity("Imp", { x: -3.95, y: 0.0, z: -15.5 });
    await rg.entityExists(target);
    await rg.entityHasAttribute(target, "health", 15);

    // approach the entity
    rg.performAction("ApproachObject", {
        targetId: target.id,
        range: 5,
    });

    // queue three attacks
    // each one should do 5 damage
    const args = {
        targetId: target.id,
        xPosition: target.position,
    }
    rg.performAction("BasicAttack", args)
    await rg.entityHasAttribute(target, "health", 10);

    rg.performAction("BasicAttack", args)
    await rg.entityHasAttribute(target, "health", 5);

    rg.performAction("BasicAttack", args)
    await rg.entityDoesNotExist(target);

    isFinished = true;
}
```

</TabItem>

<TabItem value="runTurn_menuBot" label="Click buttons to start the game">

```javascript
let isFinished = false;

/**
 * Defines the type of character that the game should use for this Bot.
 */
export function getCharacterType() {
    return {
        characterClass: null
    }
}

/**
 * One of ...
 * MANAGED - Server disconnects/ends Bot on match/game-scene teardown
 * PERSISTENT - Bot is responsible for disconnecting / ending itself
 */
export function getBotLifecycle() {
    return 'PERSISTENT';
}

/**
 * @returns {boolean} true if I'm an in-game character, or false if I'm an invisible navigator/observer/etc.
 */
export function isSpawnable() {
    return false;
}

/**
 * Let server know if I have finished my processing
 * @returns {boolean} true if done processing and ready to be torn down
 */
export function isComplete() {
    return isFinished;
}

/**
 * Clicks buttons to get us from the Main Menu into the dungeon.
 * Once we enter the dungeon, this Bot has completed its tasks.
 */
export async function configureBot(rg) {

    rg.automatedTestMode = true;

    // validate we're on the main menu
    await rg.waitForScene("MainMenu");

    // get to the character select screen
    const profileMenuButton = await rg.findEntity("ProfileMenuButton");
    await rg.entityHasAttribute(profileMenuButton, "interactable", true);
    rg.performAction("ClickButton", {targetId: profileMenuButton.id});

    const selectProfileButton = await rg.findEntity("SelectProfileButton");
    await rg.entityHasAttribute(selectProfileButton, "interactable", true);
    rg.performAction("ClickButton", {targetId: selectProfileButton.id});

    const startWithRGButton = await rg.findEntity("StartWithRGButton");
    await rg.entityHasAttribute(startWithRGButton, "interactable", true);
    rg.performAction("ClickButton", {targetId: startWithRGButton.id});

    // now we should be on a loading screen
    await rg.waitForScene("LoadingScreen");

    // select a character then enter the dungeon
    const selectHealerButton = await rg.findEntity("SelectHealerButton");
    await rg.entityHasAttribute(selectHealerButton, "interactable", true);
    rg.performAction("ClickButton", {targetId: selectHealerButton.id});

    const readyButton = await rg.findEntity("ReadyButton");
    await rg.entityHasAttribute(readyButton, "interactable", true);
    rg.performAction("ClickButton", {targetId: readyButton.id});

    // we should be in the dungeon now
    await rg.entityDoesNotExist(selectHealerButton);
    await rg.entityDoesNotExist(readyButton);
    await rg.waitForScene("Dungeon");

    // we're done!
    isFinished = true;
}
```

</TabItem>
</Tabs>

## Methods

These methods are in addition to the APIs defined in the [previous section](./playtest-bots#variables).

### `setDefaultTimeout(timeout: number);`

Sets a default timeout in milliseconds. The validator will retry until a condition succeeds.
If this timeout is hit first, then the validator will report a failure. 

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`timeout` | `number` | | The new default timeout

#### Return Value
No return value

#### Examples

```javascript
const myBot = rg.getBot();
```

### `async waitForScene(sceneName: string);`

Wait until the current scene name matches the expected value.

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`sceneName` | `string` | | The name of the scene to wait for

#### Return Value
Promise&lt;void&gt;

#### Examples

```javascript
await rg.waitForScene("StartupScreen");
await rg.waitForScene("UpdaterSplash");
await rg.waitForScene("MainMenu")
```

