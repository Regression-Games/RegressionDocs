---
sidebar_label: 'PlayTest Bots'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Defining Bots for PlayTesting

Your Unity integration collects state information about game objects and notifies the Bot runtime with the updated state at a fixed tick interval.
Whenever the Bot runtime receives an update, Regression Games calls the `runTurn` method. This is the entrypoint into your Bot logic for each tick.        

The following API is accessible through an `rg` object passed to the `runTurn` method, and is used to evaluate the current game state and queue behaviors you've defined as `RGActions`.
In-game movements and `RGActions` are automatically recorded during each session. 
These logs can be loaded into the Unity Bot Replay utility which allows you to re-watch the session and debug Bot behaviors tick-by-tick. 
API methods that filter state objects and check conditions will record additional decision results. 
These are displayed side-by-side with Bot actions in the Replay utility to help debug your Bot by showing which decisons led to resulting behaviors.  

:::tip
PlayTest Bots are useful for simulating autonomous characters whose actions will change depending on conditions in the game state.
:::

:::caution
Commands within `runTurn` interact with the game state represented by the current tick only.
This contrasts with [Validation Bots](./validation-bots), which can delay execution of commands for several ticks until expected prerequisites have been met. 
:::

<Tabs>
<TabItem value="runTurn_coopBot" label="Follow and support a human player as an NPC" default>

```javascript
/**
 * Defines the spawn characteristics for this Bot
 */
export function getCharacterConfig() {
    return {
        characterRole: "WARRIOR";
    }
}

/**
 * Outline of our Bot algorithm. For every tick:
 *  - If the Bot is standing on a switch that is holding a door open, then do nothing
 *  - If the switch is within a range of sqrt(30) units from the Bot, move onto the switch
 *  - If the Bot is not near the player, move within range of the player
 *  - If an enemy is within a certain distance of a player, attack that enemy
 */
export async function runTurn(rg) {

    if(rg.getState().sceneName !== "Dungeon") return;

    const currentPosition = rg.getBot().position;

    // if the Bot is standing on a switch that is holding a door open, then do nothing
    const floorSwitch = await rg.findEntity("FloorSwitch");
    if(floorSwitch && await rg.entityHasAttribute(floorSwitch, "isOn", true)) return;

    // if the switch is within range of sqrt(30) units from the Bot, then move onto it
    if(floorSwitch && rg.MathFunctions.distanceSq(currentPosition, floorSwitch.position) < 30) {
        rg.performAction("ApproachObject", {
            targetId: floorSwitch.id,
            range: 0.1
        });
        return;
    }

    // if the Bot is not near the human player, then move within range of that player
    const humanPlayer = await rg.findEntity("HumanPlayer");
    if(humanPlayer && rg.MathFunctions.distanceSq(currentPosition, humanPlayer.position) > 10 ) {
        rg.performAction("ApproachObject", {
            targetId: humanPlayer.id,
            range: 2
        });
        return;
    }

    // Otherwise, attack a nearby enemy if there is one
    const enemy = await rg.findNearestEntity(null, currentPosition, (entity) => { return entity.team === 1 && !entity.broken});
    if(enemy && enemy.health > 0) {
        rg.performAction("PerformSkill", {
            skillId: 1,
            targetId: enemy.id,
            position: enemy.position,
        });
    }
}
```
</TabItem>
<TabItem value="runTurn_abilityBot" label="Cycle through castable abilities">

```javascript
/**
 * Defines the type of character that the game should use for this Bot
 */
export function getCharacterConfig() {
    return {
        characterRole: "ARCHER"
    }
}

/**
 * Entrypoint into the Bot logic
 */
export async function runTurn(rg) {

    // only activate abilities if we're ready to play
    if (rg.getState().sceneName !== "Dungeon") return;

    // select 1 ability per update
    await selectAbility(rg);
}

/**
 * Returns the ID of the next ability in our rotation
 */
function getNextAbility(rg) {
    const abilities = rg.getBot().abilities;
    const abilityIndex = CURRENT_ABILITY % abilities.length;
    return abilities[abilityIndex];
}


let CURRENT_ABILITY = 0;

/**
 * Selects an ability for this character, then queues it as an action
 */
async function selectAbility(rg) {

    const ability = getNextAbility(rg);
    if(!rg.entityHasAttribute(rg.getBot(), ["abilityAvailable", `${ability.name}`], true)) {
        // this ability is still on cooldown
        return;
    }

    const targetType = ability.targetType;
    let currentTarget;

    if (targetType === "None") 
    {
        // No target needed
        currentTarget = null;
    } 
    else if (targetType === "Enemy") {
        currentTarget = await rg.findNearestEntity(null, null, (entity) => { return entity.hostile && !entity.incapacitated } )
        if(!currentTarget) {
            // can't cast this without a valid target
            return;
        }
    } 
    else if (targetType === "Ally") {
        currentTarget = await rg.findNearestEntity(null, null, (entity) => { return !entity.hostile });
        if(!currentTarget) {
            // can't cast this without a valid target
            return;
        }
    }
  
    rg.performAction("PerformSkill", {
        skillId: ability,
        targetId: currentTarget?.id,
        position: currentTarget?.position,
    });

    CURRENT_ABILITY++;
}
```

</TabItem>

<TabItem value="runTurn_menuBot" label="Click buttons to start the game">

```javascript
/**
 * Defines the type of character that the game should use for this Bot.
 */
export function getCharacterConfig() {
    return {}
}

/**
 * One of ...
 * MANAGED - Server disconnects/ends Bot on match/game-scene teardown
 * PERSISTENT - Bot is responsible for disconnecting / ending itself
 */
export function getBotLifecycle() {
    return 'PERSISTENT';
}

/**
 * @returns {boolean} true if I'm an in-game character, or false if I'm an invisible navigator/observer/etc.
 */
export function isSpawnable() {
    return false;
}

/**
 * Let server know if i have finished my processing
 * @returns {boolean} true if done processing and ready to be torn down
 */
export function isComplete() {
    return isFinished;
}


// flags for clicking the 6 buttons we need to click to start the game
let stateFlags = {
    "ProfileMenuButton": false
    "SelectProfileButton": false,
    "StartWithRGButton": false,
}

let isFinished = false;
let playedGame = false;

/** 
 * Click buttons to get us from the Main Menu into the dungeon.
 * Once we enter the dungeon, this Bot has completed its tasks.
 */
export async function runTurn(rg) {

    if(rg.getState().sceneName === "MainMenu") {
        const profileMenuButton = await getInteractableButton("ProfileMenuButton");
        if (profileMenuButton && !stateFlags["ProfileMenuButton"]) {
            rg.performAction("ClickButton", {targetId: profileMenuButton.id});
            stateFlags["ProfileMenuButton"] = true
            return;
        }

        const selectProfileButton = await getInteractableButton("SelectProfileButton");
        if (selectProfileButton && stateFlags["ProfileMenuButton"] && !stateFlags["SelectProfileButton"]) {
            rg.performAction("ClickButton", {targetId: selectProfileButton.id});
            stateFlags["SelectProfileButton"] = true
            return;
        }

        const startButton = await getInteractableButton("StartWithRGButton");
        if (startButton && stateFlags["SelectProfileButton"] && !stateFlags["StartWithRGButton"]) {
            rg.performAction("ClickButton", {targetId: startButton.id});
            stateFlags["StartWithRGButton"] = true
            return;
        }
    } else {
        isFinished = true;
    }
}

async function getInteractableButton(buttonName) {
    const button = await rg.findEntity(buttonName);
    if (button && await rg.entityHasAttribute(button, "interactable", true)) {
        return button;
    }
    return null;
}
```

</TabItem>
</Tabs>


## Variables

### `playerId`

The ID of this Bot in the game state.

### `name`

The given name of the connected Bot

### `characterConfig`

A freeform Javascript object defining this Bot's character configuration. See [isSpawnable()](./configuration#isSpawnable) and [getCharacterConfig()](./configuration#getCharacterConfig)


## Methods

### `getState(id: number = null);`

Returns a complete state object including the current state of all registered entities

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`id` | `number` | `null` | Return state information for a specific state entity

#### Return Value
Returns information about the current state

#### Examples

```javascript
// get all information about the current state
const fullState = rg.getState();

// get the current state of a known entity
const mascot = await rg.findEntity("Williward");
...
const objectState = rg.getState(mascot.id); 
```

### `getBot();`

Returns the current state information for this Bot.  
Synonymous with `rg.getState(rg.playedId)`

#### Arguments
None

#### Return Value
Returns the current state information for this Bot

#### Examples

```javascript
const myBot = rg.getBot();
```

### `complete()`;

Flags the current Bot as complete (see [isComplete()](./configuration#isComplete))

#### Arguments
None

#### Return Value
No return value

#### Examples

```javascript
rg.complete();
```

### `performAction(actionName: string, args: object | null);`

Queues an action that the Bot should perform. Action names are freeform strings and must correspond to the name of one of your defined `RGActions`.
Actions do not necessarily start executing the same tick that they were queued.  

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`actionName` | `string` | | The name of an action, as defined by its corresponding `RGAction`
`args` | `object` | | Any arguments that should be passed to the `RGAction`

#### Return Value
No return value

#### Examples

<Tabs>
<TabItem value="performAction_simple" label="Open a Door" default>

```javascript
const door = await rg.findEntity("Door");
rg.performAction("OpenDoor", { targetId: door.id });
```

</TabItem>
<TabItem value="performAction_arguments" label="Equip a sword">

```javascript
const bot = rg.getBot();
if(!await rg.entityHasAttribute(bot, "equippedItem", "sword")) {
    rg.performAction("EquipItem", { 
        itemName: "sword",
        slot: "mainHand" 
    });
}
```
</TabItem>
</Tabs>

### `findEntity(objectType: string);`

Find an entity with the given Object Type in the game state.
This method should be used when only one entity with the given Object Type is expected to exist in the state,
or when any entity with this Object Type will satisfy the scenario.
For more control over finding specific entities in the game state, see [getState](./playtest-bots#getState) and [findNearestEntity](./playtest-bots#findNearestEntity).

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`objectType` | `string` | | The objectType to search for, as defined by the entity's corresponding `RGState`

#### Return Value
Promise&lt;object | null&gt;

#### Examples


```javascript
const door = await rg.findEntity("Door");
const humanPlayer = await rg.findEntity("HumanPlayer");
const areaBoss = await rg.findEntity("Boss");
```

### `findNearestEntity(objectType: string | null, position: object = null, filterFunc: function = (entity) => true);`

Finds the closest entity to the given position.

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`objectType` | `string` &#124; `null` | | Optionally filter entities by type 
`position` | `object` | The Bot's current position | The position to measure distance from
`filterFunc` | `function` | (entity) => true | Optionally filter entities to find 

#### Return Value
Promise&lt;object | null&gt;

#### Examples

<Tabs>
<TabItem value="findNearestEntity_default" label="No Filter" default>

```javascript
const williward = await rg.findNearestEntity("Williward");
const enemyNearestToWilliward = await rg.findNearestEntity("Enemy", williward.position);
```

</TabItem>
<TabItem value="findNearestEntity_filtered" label="Filter">

```javascript
const patrolPoint = await rg.findEntity("PatrolPoint");
const guardOnPatrol = await rg.findNearestEntity("Guard", patrolPoint.position, (entity) => { return !entity.isAsleep });
```

</TabItem>
</Tabs>

### `entityExists(entity: object | number | string);`

Return whether the given entity exists.
The `entity` argument can be a reference to a previously-existing entity, its id, or an Object Type.
If this is an Object Type, will return true if _any_ entities with this ObjectType exist. 

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`entity` | `object` &#124; `number` &#124; `string` | | The entity, its id, or an Object Type. If this is an Object Type, will return true if _any_ entities with this ObjectType exist. 

#### Return Value
Promise&lt;boolean&gt;

#### Examples

<Tabs>
<TabItem value="entityExists_entity" label="Entity" default>

```javascript
const entity = await rg.findEntity("Williward");
... 
const exists = await rg.entityExists(entity);
```

</TabItem>
<TabItem value="entityExists_id" label="Entity ID">

```javascript
const entity = await rg.findEntity("Williward");
... 
const exists = await rg.entityExists(entity.id);
```

</TabItem>
<TabItem value="entityExists_objectType" label="Object Type">

```javascript
const exists = await rg.entityExists("Williward");
```

</TabItem>
</Tabs>

### `entityDoesNotExist(entity: object | number | string);`

Return whether the given entity does not exist.
The `entity` argument can be a reference to a previously-existing entity, its id, or an Object Type.
If this is an Object Type, will return true if _no_ entities with this ObjectType exist. 

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`entity` | `object` &#124; `number` &#124; `string` | | The entity, its id, or an Object Type. If this is an Object Type, will return true if _no_ entities with this ObjectType exist. 

#### Return Value
Promise&lt;boolean&gt;

#### Examples

<Tabs>
<TabItem value="entityDoesNotExist_entity" label="Entity" default>

```javascript
const staleEntity = await rg.findEntity("Williward");
... 
const exists = await rg.entityDoesNotExist(staleEntity);
```

</TabItem>
<TabItem value="entityDoesNotExist_id" label="Entity ID">

```javascript
const staleEntity = await rg.findEntity("Williward");
... 
const exists = await rg.entityDoesNotExist(staleEntity.id);
```

</TabItem>
<TabItem value="entityDoesNotExist_objectType" label="Object Type">

```javascript
const exists = await rg.entityDoesNotExist("Williward");
```

</TabItem>
</Tabs>


### `entityHasAttribute(targetEntity: object, stateAttribute: string | string[], expectedValue: any);`

Return whether the entity in the game state has the expected value for one of its attributes.

#### Arguments
Argument Name | Type | Default | Description
---|---|---|---|
`targetEntity` | `object` | | The entity
`stateAttribute` | `string` &#124; `string[]` | | The name of the attribute key, or an array of keys for nested attributes
`expectedValue` | `any` | | The expected value for the entity's state attribute

#### Return Value
Promise&lt;boolean&gt;

#### Examples

<Tabs>
<TabItem value="entityHasAttribute_entity" label="Attribute" default>

```javascript
const entity = await rg.findEntity("Williward");
if(await rg.entityHasAttribute(entity, "color", "teal")) {
    console.log("Williward is looking good!")
}
```

</TabItem>
<TabItem value="entityHasAttribute_id" label="Nested Attribute">

```javascript
const entity = await rg.findEntity("Boss");
if(await rg.entityHasAttribute(entity, ["healthObject", "currentHealth"], 1000)) {
    console.log("The boss is at full health")
}
```
</TabItem>
</Tabs>


