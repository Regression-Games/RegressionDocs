---
sidebar_label: 'Defining States'
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Defining States

The state of the game sent to Regression Games includes only GameObjects selected to be part of the state.

:::info
Exposing every field or property of each Behaviour on every GameObject is too much information to capture each each tick in all but the smallest of games.

The methods for exposing state listed below make it quick and easy to expose exactly the amount of state you need.
:::

## Ways to include a GameObject in the state...

### 1 - `RGStatefulGameObject` MonoBehaviour
By adding the `RGStatefulGameObject` behaviour to a GameObject, that GameObject will be included in the state.
Unless one of the other methods is used, this will include only the [core](#core-state-properties) state properties of the GameObject.

:::info
Adding `RGStatefulGameObject` to a GameObject is **NOT** required when using any of the other methods described below.

`RGStatefulGameObject` is only useful for GameObjects that should be included in the state, but that do not have any of the attributes below.
:::

Each GameObject is included in the overall state dictionary keyed by its `id`.

#### Core State Properties
 The core state for each GameObject is put into the state dictionary as an `RGStateEntity_Core` which provides fields for each
of the core state properties.  Any other state properties can be retrieved using the `GetField` methods on the core StateEntity for a GameObject.

| Name          | Type         | Description                                                                                                                                                                                                                                 |
|---------------|--------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `id`          | `int`        | The transform id of this GameObject.                                                                                                                                                                                                        |  
| `name`        | `string`     | The name of this GameObject as seen in the editor.                                                                                                                                                                                          |
| `tag`         | `string`     | The tag of this GameObject as seen in the editor, can be null if GameObject is untagged.                                                                                                                                                    |
| `scene`       | `string`     | The name of the scene this GameObject is part of.                                                                                                                                                                                           |
| `pathInScene` | `string`     | The full path to this GameObject in its scene.                                                                                                                                                                                              |
| `position`    | `Vector3`    | The position of this GameObject in world space.                                                                                                                                                                                             |
| `rotation`    | `Quaternion` | The rotation of this GameObject in world space.                                                                                                                                                                                             |
| `isPlayer`    | `boolean`    | If true, this GameObject has a MonoBehaviour representing a player controlled object. That player may or may not be driven by a bot.  (See the [[RGStateType](#2---rgstatetype-class-level-attribute)] section below for more information.) |
| `clientId`    | `long?`      | The id of the client that owns/controls this GameObject if it represents a bot.  This field can be null.                                                                                                                                    |


### 2 - `[RGStateType]` Class Level Attribute
By adding the `[RGStateType]` attribute to any MonoBehaviour class in your project, ALL GameObjects with that MonoBehaviour attached will be included in the state.

Any MonoBehaviour using this attribute will be included in the state under a property named the same as the Behaviour's class name or the `typeName` specified by this attribute.

When this attribute is used in a class, a new source file will be autogenerated by Regression Games to represent this entity in the state.
If this class includes `[RGState]` attributes on fields, properties, or methods, then only those will be included in the state.
Otherwise, all public fields, properties, and zero parameter methods with return values will be included.

#### `[RGStateType]` Example 1
This example shows using `[RGStateType]` with `IsPlayer` set to `true` to indicate that GameObjects with this MonoBehaviour should be considered players.

Source File: KingState.cs
```cs
[RGStateType(IsPlayer = true)]
public class KingState : MonoBehaviour
{
    public string CharacterType()
    {
        return "King";
    }

    public int Health()
    {
        return 100;
    }
}
```

Generated File: RGStateEntity_KingState.Generated.cs
```cs
public class RGStateEntity_KingState : RGStateEntityBase
{
    public static readonly Type BehaviourType = typeof(KingState);
    public static readonly string EntityTypeName = "KingState";
    public static readonly bool IsPlayer = true;
    
    public override string GetEntityType()
    {
        return EntityTypeName;
    }

    public override bool GetIsPlayer()
    {
        return IsPlayer;
    }

    public override void PopulateFromMonoBehaviour(MonoBehaviour monoBehaviour)
    {
        var behaviour = (KingState)monoBehaviour;
        this["CharacterType"] = behaviour.CharacterType();
        this["Health"] = behaviour.Health();
    }
    
    public string CharacterType => (string)this["CharacterType"];
    public int Health => (int)int.Parse(this.GetField("Health").ToString());
}
```

In addition to the [core](#core-state-properties) state properties, this GameObject will also have a property in the state for this generated class.

| Name        | Type                      | Description                                                       |
|-------------|---------------------------|-------------------------------------------------------------------|
| `KingState` | `RGStateEntity_KingState` | The properties of the KingState MonoBehaviour on this GameObject. |

Also note that if any Behaviour on a GameObject indicates that `isPlayer` is `true` as this example does, then the [core](#core-state-properties) state for that GameObject will show the value
of `isPlayer` as `true`.

#### `[RGStateType]` Example 2
This example shows using `[RGStateType]` with `IsPlayer` set to `true` to indicate that GameObjects with this MonoBehaviour should be considered players.
This example also overrides the `typeName` of this Behaviour that will be used in the state.

Source File: PawnState.cs
```cs
[RGStateType("mockPawnState", IsPlayer = true)]
public class PawnState : MonoBehaviour
{
    public string CharacterType()
    {
        return "Pawn";
    }

    public int Health()
    {
        return 1;
    }
}
```

Generated File: RGStateEntity_PawnState.Generated.cs
```cs
public class RGStateEntity_PawnState : RGStateEntityBase
{
    public static readonly Type BehaviourType = typeof(PawnState);
    public static readonly string EntityTypeName = "mockPawnState";
    public static readonly bool IsPlayer = true;
    
    public override string GetEntityType()
    {
        return EntityTypeName;
    }

    public override bool GetIsPlayer()
    {
        return IsPlayer;
    }

    public override void PopulateFromMonoBehaviour(MonoBehaviour monoBehaviour)
    {
        var behaviour = (PawnState)monoBehaviour;
        this["CharacterType"] = behaviour.CharacterType();
        this["Health"] = behaviour.Health();
    }
    
    public string CharacterType => (string)this["CharacterType"];
    public int Health => (int)int.Parse(this.GetField("Health").ToString());
}
```

In addition to the [core](#core-state-properties) state properties, this GameObject will also have a property in the state for this generated class.
Note that this property name uses the specified `typeName` from the `[RGStateType]` attribute.

| Name            | Type                      | Description                                                       |
|-----------------|---------------------------|-------------------------------------------------------------------|
| `mockPawnState` | `RGStateEntity_PawnState` | The properties of the PawnState MonoBehaviour on this GameObject. |

Also note that if any Behaviour on a GameObject indicates that `isPlayer` is `true` as this example does, then the [core](#core-state-properties) state for that GameObject will show the value
of `isPlayer` as `true`.

#### `[RGStateType]` Example 3
This example shows using `[RGStateType]` with `IncludeFlags` set to `RGStateIncludeFlags.NONE` to indicate that GameObjects with this MonoBehaviour should be included in the state but without exposing any of their field values.
This example also overrides the `typeName` of this Behaviour that will be used in the state.

Source File: FieldlessState.cs
```cs
[RGStateType("mockFieldlessState", IncludeFlags = RGStateIncludeFlags.NONE)]
public class FieldlessState : MonoBehaviour
{
    public string CharacterType()
    {
        return "Fieldless";
    }

    public int Health()
    {
        return -1;
    }
}
```

Generated File: RGStateEntity_FieldlessState.Generated.cs
```cs
public class RGStateEntity_FieldlessState : RGStateEntityBase
{
    public static readonly Type BehaviourType = typeof(FieldlessState);
    public static readonly string EntityTypeName = "mockFieldlessState";
    public static readonly bool IsPlayer = false;
    
    public override string GetEntityType()
    {
        return EntityTypeName;
    }

    public override bool GetIsPlayer()
    {
        return IsPlayer;
    }

    public override void PopulateFromMonoBehaviour(MonoBehaviour monoBehaviour)
    {
    }
}
```

In addition to the [core](#core-state-properties) state properties, this GameObject will also have a property in the state for this generated class.
Note that this property name uses the specified `typeName` from the `[RGStateType]` attribute.

| Name                 | Type                           | Description                                                            |
|----------------------|--------------------------------|------------------------------------------------------------------------|
| `mockFieldlessState` | `RGStateEntity_FieldlessState` | The properties of the FieldlessState MonoBehaviour on this GameObject. |

### 3 - `[RGState]` Field/Property/Method Attribute
By adding the `[RGState]` attribute to any field, property, or zero parameter methods with return values in a MonoBehaviour class in your project, ALL GameObjects with that MonoBehaviour attached will be included in the state.

Any MonoBehaviour using this attribute will be included in the state under a property named the same as the Behaviour's class name or the `typeName` specified in its `[RGStateType]` attribute if it has that attribute.

:::info
`[RGState]` **DOES NOT** require using `[RGStateType]`.  A generated class will still be created for your Behaviour with only `[RGState]` attributes present.

You can use both attributes when you want to specify `isPlayer` as `true` or want to override the `typeName` used for the property name in the state.
:::

When this attribute is used in a class, a new source file will be autogenerated by Regression Games to represent this entity in the state.
Only fields, properties, or methods with this attribute specified will be included in the state.

#### `[RGState]` Example 1
This example shows using `[RGState]` without using `[RGStateType]`.  This example also overrides the name of the `CharacterType` property to `charType`.

Source File: WandererState.cs
```cs
public class WandererState : MonoBehaviour
{
    [RGState("charType")]
    public string CharacterType()
    {
        return "Wanderer";
    }

    public int Health()
    {
        return 50;
    }
}
```

Generated File: RGStateEntity_WandererState.Generated.cs
```cs
public class RGStateEntity_WandererState : RGStateEntityBase
{
    public static readonly Type BehaviourType = typeof(WandererState);
    public static readonly string EntityTypeName = "WandererState";
    public static readonly bool IsPlayer = false;
    
    public override string GetEntityType()
    {
        return EntityTypeName;
    }

    public override bool GetIsPlayer()
    {
        return IsPlayer;
    }

    public override void PopulateFromMonoBehaviour(MonoBehaviour monoBehaviour)
    {
        var behaviour = (WandererState)monoBehaviour;
        this["charType"] = behaviour.CharacterType();
    }
    
    public string charType => (string)this["charType"];
}
```

Note that the `Health` property is **NOT** included because it does not have an `[RGState]` attribute.

In addition to the [core](#core-state-properties) state properties, this GameObject will also have a property in the state for this generated class.

| Name            | Type                          | Description                                                           |
|-----------------|-------------------------------|-----------------------------------------------------------------------|
| `WandererState` | `RGStateEntity_WandererState` | The properties of the WandererState MonoBehaviour on this GameObject. |



#### `[RGState]` Example 2
This example shows using `[RGState]` while also using `[RGStateType]`.

Source File: NomadState.cs
```cs
[RGStateType("nomad")]
public class NomadState : MonoBehaviour
{
    public string CharacterType()
    {
        return "Nomad";
    }

    [RGState]
    public int Health()
    {
        return 50;
    }
}
```

Generated File: RGStateEntity_NomadState.Generated.cs
```cs
public class RGStateEntity_NomadState : RGStateEntityBase
{
    public static readonly Type BehaviourType = typeof(NomadState);
    public static readonly string EntityTypeName = "nomad";
    public static readonly bool IsPlayer = false;
    
    public override string GetEntityType()
    {
        return EntityTypeName;
    }

    public override bool GetIsPlayer()
    {
        return IsPlayer;
    }

    public override void PopulateFromMonoBehaviour(MonoBehaviour monoBehaviour)
    {
        var behaviour = (NomadState)monoBehaviour;
        this["Health"] = behaviour.Health();
    }
    
    public string Health => (string)this["Health"];
}
```

Note that the `CharacterType` property is **NOT** included because it does not have an `[RGState]` attribute.

In addition to the [core](#core-state-properties) state properties, this GameObject will also have a property in the state for this generated class.

| Name    | Type                       | Description                                                        |
|---------|----------------------------|--------------------------------------------------------------------|
| `nomad` | `RGStateEntity_NomadState` | The properties of the NomadState MonoBehaviour on this GameObject. |


### 4 - `RGActionBehaviour` MonoBehaviour
By adding a Behaviour that extends `RGActionBehaviour` to a GameObject, that GameObject will be included in the state.
Unless one of the other methods is also used, this will include only the [core](#core-state-properties) state properties of the GameObject and
a property with the name of class extending `RGActionBehaviour`.  The value of the property will be `RGStateEntity_Empty` which has no field accessors.

:::info
RGActionBehaviour is an abstract class allowing for fully custom bot action implementations.

It is currently available and used internally for handling button click actions, but is still under development and may be subject to change or breakage going forward.
:::

See [Defining Actions](../integrating-with-unity/defining-actions) for more information about defining actions.

### 5 - `[RGAction]` Attribute

By adding the `[RGAction]` attribute to any method in a MonoBehaviour class in your project, ALL GameObjects with that MonoBehaviour attached will be included in the state.

Any MonoBehaviour using this attribute will be included in the state under a property named the same as the Behaviour's class name or the `typeName` specified in its `[RGStateType]` attribute if it has that attribute.

:::info
`[RGAction]` **DOES NOT** require using `[RGStateType]`.  Your Behaviour will still be included as a property in the state with only `[RGAction]` attributes present.

You can use both attributes when you want to specify `isPlayer` as `true` or want to override the `typeName` used for this Behaviour in the state.
:::

See [Defining Actions](../integrating-with-unity/defining-actions) for more information about defining actions.
